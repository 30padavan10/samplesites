--Представление(контроллер)--
Любой контроллер-функция в качестве единственного обязательного параметра принимает экземпляр класса HttpRequest, хранящий различные сведения о полученном запросе: запрашиваемый интернет-адрес, данные, полученные от посетителя, служебную информацию от самого веб-обозревателя и пр. По традиции этот параметр называется request. 

В теле функции экземпляр класса HttpResponse (он объявлен в модуле django.http) будет представлять отправляемый клиенту ответ. 


--Марштруты--
При поступлении любого запроса от клиента Django разбирает его на составные части (чем занимается целая группа программных модулей, называемых посредники), извлекает запрошенный посетителем интернет адрес, удаляет из него все составные части, за исключением пути, который передает маршрутизатору. Последний последовательно сравнивает его с шаблонными адресами, записанными в списке маршрутов. Как только будет найдено совпадение, маршрутизатор выясняет, какой контроллер связан с совпавшим шаблонным адресом, и передает этому контроллеру управление. 

----Параметризованные запросы----
Предположим нам нужно отфильтровывать из модели определенные записи(с определенным атрибутом), например название рубрики. Чтобы контроллер, который будет отфильтровывать из модели объявления, относящиеся к выбранной рубрике, смог, собственно, их отфильтровать, он должен получить ключ рубрики.

Этот ключ удобнее всего передать в составе интернет-адреса, через GЕТ-параметр: /bboard/?rubric=<ключ рубрики>. Однако Django предлагает нам другую возможность выполнить передачу параметров в контроллер - непосредственно в составе пути интернет-адреса: bboard/<ключ рубрики> 

Для этого нужно указать маршрутизатору, какую часть пути считать URL-параметром, каков тип этого параметра, и какое имя у параметра.
urlpatterns = [
	path( '<int:rubric_id>/', by_ruЬric),
]
<> - параметр указывается в угловых скобках
int - тип целое число 
rubric_id - имя параметра

Чтобы передать параметр контроллеру контроллер-функция должна иметь помимо атрибута request еще и этот атрибут
	def by_rubric(request, rubric_id):
	
----Обратное разрешение интернет-адресов----
Если мы решим изменить шаблонный интернет-адрес в списке маршрутов, нам придется вносить уйму правок и в код шаблонов. Существует инструмент Django, называемый обратным разрешением интернет-адресов. Его суть: мы указываем маршрут, формирующий нужный нам интернет-адрес(значения URL-параметров - если требуется), а Django сам генерирует на основе всего этого правильный интернет-адрес. 
Для этого нужно:
1. Дать маршрутам имена, создав тем самым именованные маршруты.
	path ( '<int: rubric_id>/', by_rubric, name='by_rubric'),

2. Использование в гиперссылках тегов шаблонизатор url. Имя маршрута указывается первым параметром. Значение URL-параметра - вторым.
	<а href="{% url 'by_rubric' rubric.pk %}">
	
ВНИМАНИЕ! С именованными параметрами нужно быть внимательным.
Если формируем ссыллку внутри цикла из модели Rubric, то обращаемся к параметру как rubric.pk:
{% for rubric in rubrics %}
    <a href="{% url 'by_rubric' rubric.pk %}">{{ rubric.name }}</a>	
А если формируем ссылку внутри цикла из модели Bb, то обращаться к параметру нужно уже как bb.rubric.pk:
{% for bb in bbs %}
    <p><a href="{% url 'by_rubric' bb.rubric.pk %}">{{ bb.rubric.name }}</a></p>


----Интернет-адрес модели и его формирование----
Django позволяет сформировать интернет-адрес, указывающий на конкретную запись модели, - интернет-адрес модели. По этому адресу может находиться страница с содержимым этой записи, списком связанных записей и др. Сформировать интернет-адрес модели можно двумя способами: декларативным и императивным.

Декларативный способ заключается в том, что мы описываем формат интернет-адреса в настройках проекта. Набор таких адресов оформляется в виде словаря Python и записывается в параметре ABSOLUTЕ_URL_OVERRIDES модуля settings.py пакета конфигурации.
Ключи элементов этого словаря должны иметь вид <псевдоним приложения>.<имя класса модели>. Значениями элементов станут функции, в качестве единственного параметра принимающие объект записи модели, а в качестве результата возвращающие строку с готовым интернет-адресом. Здесь удобно использовать лямбда-функции Python.
Пример объявления словаря, который на основе рубрики (экземпляра класса модели Rubric) сформирует интернет-адрес вида /bboard/<ключ рубрики>/, ведущий на страницу со списком относящихся к этой рубрике объявлений:
    AВSOLUTE_URL_OVERRIDES = {
        'bboard.rubric': lambda rec: "/bboard/%s/" % rec.pk,
        }
Теперь, чтобы поместить в код шаблона интернет-адрес модели, нам достаточно вставить туда вызов метода get_absolute_url(), унаследованного всеми моделями от базового класса Model:
    <а href="{{ rubric.get_absolute_url }}">{{ rubric.name }}</а>
Точно таким же образом можно получить интернет-адрес модели где-либо еще -например, в коде контроллера.

Императивный способ заключается в непосредственном переопределении метода get_absolute_url() в классе модели. Вот пример:
    class Rubric(models.Model):
        def get_absolute_url(self):
            return "/bboard/%s/" % self.pk
Разумеется, в параметре AВSOLUTE_URL_OVERRIDES настроек проекта в таком случае нет нужды.

--Модель--
Модель - это описание сущности, хранящейся в базе данных в виде класса Python. Класс модели описывает таблицу базы данных,в которой будет храниться набор сущностей, и атрибуты класса, каждый из которых описывает одно из полей таблицы. Можно сказать, что модель это представление таблицы и ее полей средствами Python. 
Отдельный экземпляр класса модели представляет отдельную конкретную сущность, извлеченную из базы, т. е. отдельную запись соответствующей таблицы.
Пользуясь объявленными в модели атрибутами класса, мы можем получать значения, хранящиеся в полях записи, равно как и записывать в них новые значения. 

Все классы моделей поддерживают атрибут класса objects. Он хранит диспетчер записей - особую структуру, позволяющую манипулировать всей совокупностью имеющихся в модели записей. Диспетчер записей представляется экземпляром класса Manager.

По поводу низкоуровневых структур, создаваемых в базе данных и используемых моделью для хранения сущностей, можно отметить следующее:
- каждая модель представляет отдельную таблицу в базе данных;
- по умолчанию таблицы, представляемые моделями, получают имена вида <псевдоним приложения>_<имя класса модели> (в данном случае будет bboard_bb);
- каждое поле модели представляет отдельное поле в соответствующей таблице базы данных;
- по умолчанию поля в таблице получают имена, совпадающие с именами полей модели, которые их представляют(в данном случае  title, content, price ...);
- если в модели не было явно объявлено ключевое поле для хранения значения, однозначно идентифицирующего запись модели (ключа), оно будет создано самим фреймворком, получит имя id, целочисленный тип, будет помечено как автоинкрементное, и для него будет создан ключевой индекс;
- по умолчанию никакие дополнительные индексы в таблице не создаются.

Модель может быть создана для представления как уже существующей в базе таблицы (в этом случае при объявлении модели нам придется дополнительно указать
имя таблицы и имена всех входящих в нее полей), так и еще не существующей (тогда для создания таблицы нам нужно сгенерировать миграцию).


Метод create () диспетчера записей создает новую запись модели, принимая в качестве набора именованных параметров значения ее полей. При этом он сразу же сохраняет созданную запись и возвращает ее в качестве результата. 

Метод all ( ) диспетчера записей возвращает набор записей. Сам набор записей представляется экземпляром класса Queryset, а отдельные записи - экземплярами соответствующего класса модели. Поскольку набор записей является последовательностью и поддерживает итерационный протокол, мы можем перебрать его в цикле. 

Метод order_Ьу ( ) диспетчера записей сортирует записи по значению поля, чье имя указано в параметре.(for Ь in Bb.objects.order_by('title'))
Метод filter () диспетчера записей выполняет фильтрацию записей по заданным критериям.(for Ь in Bb.objects.filter(title='Дoм'))
Метод get ( ) диспетчера записей имеет то же назначение, что и метод fi1ter( ), и вызывается аналогичным образом. Однако он ищет не все записи, подходящие под заданные критерии, а лишь одну и возвращает ее в качестве результата. К тому же, он работает быстрее метода filter(). 


Вложенный класс Mеtа содержит атрибуты класса, которые задают параметры самой модели:
verbose_name_plural - название набора сущностей, хранящихся в модели, которая будет выводиться на экран;
verbose_name - название сущности, хранящейся в модели, которое будет выводиться на экран.
Эти названия также будут выводиться на экран в админке сайта.
ordering - последовательность полей, по которым по умолчанию будет выполняться сортировка записей. 
unique together - последовательность имен полей, представленных в виде строк, которые должны хранить уникальные в пределах таблицы комбинации
значений. 
    class Meta:
        unique_together = (
            ('title', 'published'),
            ('title', 'price', rubric),
            )
Теперь комбинация названия товара и даты публикации объявления должна быть уникальной в пределах модели. Тоже самое для комбинации названия, цены и рубрики.

Параметры поддерживаемые всеми типами полей:
- verbose_name указывает "человеческое" название поля, которое будет выводиться на экран на страницах административного сайта и напротив элементов управления в веб-формах. Если оно не указано, в таковом качестве будет использовано имя поля.
- help_text - дополнительный поясняющий текст, выводимый на экран. Значение по умолчанию - пустая строка. 
- unique - если True, в текущее поле может быть занесено только уникальное в пределах таблицы значение (уникальное поле). При попытке занести значение, уже имеющееся в том же поле другой записи, будет возбуждено исключение IntegrityError из модуля django.db. Если поле помечено как уникальное, по нему автоматически будет создан индекс. Поэтому явно задавать для него индекс не нужно. 
- null - если True, поле в таблице базы данных может хранить значение null и, таким образом, являться необязательным к заполнению. Параметр null затрагивает только поле таблицы, но не поведение Django. Даже если какое-то поле присвоением параметру значения тrue было помечено как необязательное, фреймворк по умолчанию все равно не позволит занести в него пустое значение;
-blank - если тrue, Django позволит занести в поле пустое значение, тем самым сделав поле необязательным к заполнению. Параметр blank задает поведение самого фреймворка при выводе на экран веб-форм и проверке введенных в них данных. Если для этого параметра бьmо указано значение true, Django позволит занести в поле пустое значение (например, для строкового поля - пустую строку), даже если это поле было помечено как обязательное к заполнению (параметру null было дано значение False);
- choices - последовательность значений, доступных для занесения в текущее поле. Может быть использован для создания полей, способных хранить ограниченный набор значений, которые посетитель выбирает из списка(поле со списком). Если значение поля должно быть текстовым, то и значение 1-го элемента должно быть текстовое и т.д.

class Bb(models.Model):
КINDS = (
( 'b', 'Куплю'),
( 's' , ' Продам' ) ,
( 'с' , 'Обменяю' ) ,
)

kind = models.CharField(max_length=l, choices=KINDS) 

- db_index - если True, по текущему полю в таблице будет создан индекс, если False - не будет. Значение по умолчанию- False;
- primary_key - если True, текущее поле станет ключевым. При этом ключевое поле будет помечено как обязательное к заполнению и уникальное (параметру null неявно будет присвоено значение False, а параметру unique - True).

----Редактор модели в админке сайта----
На странице списка записей в админке все позиции представляются невразумительными строками вида <имя класса модели> object (<значение ключа>)" из которых невозможно понять, что же хранится в каждой из этих записей. Но можно вывод данной информации редактировать.

В admin.py создаем редактор модели, который объявляется как подкласс admin.ModelAdmin и с помощью атрибута list_display указываем какие поля записи должны отображаться. 
list_display_links - создает ссылку на редактирование записи,
search_fields - добавляет поле для поиска.

class BbAdmin(admin.ModelAdmin):
	list_display = ('title', 'content', 'price', 'published')
	list_display_links = ('title', 'content')
	search_fields = ('title', 'content',)
admin.site.register(Bb, BbAdmin) 

Этот способ лучше всего подходит только для моделей с несколькими значащими полями, если же такое поле в модели всего одно, проще переопределить метод __str__ в самой модели.

class Rubric(models.Model):
	def __str__(self) :
		return self.name 


----Связь между моделями----

"один со многими"
Для связи между моделями во вторичную модель добавляется внешний ключ, устанавливающий связь между этой модель и записью первичной модели. Таким образом будет создана связь "один со многими".

rubric = models.ForeignKey('Rubric', null=Тrue, on_delete=models.PROTECT, vеrbоsе_name='Рубрика')

Первым параметром:
- Rubric - ссылка на класс - если код, объявляющий класс первичной модели, располагается перед кодом класса вторичной модели; 
- 'Rubric' - строки с именем класса - если вторичная модель объявлена раньше первичной
- Если необходимо передать ссылку на модель, объявленную в другом приложении проекта, необходимо использовать строку формата <имя прwюжения>.<имя класса модели>: 'rubrics.Rubric'
- Если нужно создать модель, ссылающуюся на себя (создать рекурсивную связь), первым параметром конструктору следует передать строку 'self'. 

null=Тrue Все поля, создаваемые в моделях, по умолчанию обязательны к заполнению. Следовательно, добавить новое, обязательное к заполнению поле в модель, которая
уже содержит записи, нельзя - сама СУБД откажется делать это и выведет сообщение об ошибке. Нам придется явно пометить поле ruЬric как необязательное,
присвоив параметру null значение true - только после этого поле будет успешно добавлено в модель. 

Параметр on_delete управляет каскадными удалениями записей вторичной модели после удаления записи первичной модели, с которой они были связаны.
- CASCADE - удаляет все связанные записи вторичной модели (каскадное удаление); 
- РRОТЕСТ - возбуждает исключение ProtectedError из модуля django.db.models, тем самым предотвращая удаление записи первичной модели;
- SET_NULL - заносит в поле внешнего ключа всех связанных записей вторичной модели значение null. Сработает только в том случае, если поле внешнего ключа объявлено необязательным к заполнению на уровне базы данных (параметр null конструктора поля имеет значение True);
- SET_DEFAULT- заносит в поле внешнего ключа всех связанных записей вторичной модели заданное для него значение по умолчанию. Сработает только в том
случае, если у поля внешнего ключа бьmо указано значение по умолчанию (оно задается параметром default конструктора поля);
- SET (<значение>) - заносит в поле внешнего ключа указанное значение

Параметр limit_choices_to - позволяет вывести в списке связываемых записей первичной модели только те, что удовлетворяют заданным критериям фильтрации. 
Для примера укажем Django выводить только рубрики, поле visible которых содержит значение тrue:
	rubric = models.ForeignКey(Rubric, on_delete=models.PROTECT, limit_choices_to={'visible': True}) 

Параметр related_name - для доступа к записям вторичной модели через значение атрибута записи первичной модели.
	class Bb(models.Model):
		rubric = models.ForeignKey(Rubric, on_delete=models.PROTECT,related_name='entries')

# Получаем первую рубрику
first_rubric = Rubric.objects.first()
# Получаем доступ к связанным объявлениям через атрибут entries, указанный в параметре related_name
bbs = first_rubric.entries.all() 

"один-с-одним"
Связь «один-с-одним» соединяет одну запись первичной модели с одной записью вторичной модели. Такие связи служат для объединения моделей, одна из которых хранит данные, дополняющие данные из другой модели. Такая связь создается в классе вторичной модели объявлением поля типа OnetoOneField. Вот формат конструктора этого класса:
	ОnеТоОnеFiеld(<связываемая первичная модель>, оn_dеlеtе=<поведение при удалении записи>[,
<остальные параметры>])

"многие-со-многими"
Эта связь позволяет связать произвольное количество записей одной модели с произвольным количеством записей другой (обе модели здесь выступают как равноправные, и определить, какая из них первичная, а какая вторичная, не представляется возможным). Для создания такой связи нужно объявить в одной из моделей (но не в обеих сразу!) поле внешнего ключа типа ManyТoManyField. Вот формат его конструктора:
	ManyТoManyField(<втopaя связываемая модель > [<остальные параметры>])

Модель, в которой было объявлено поле внешнего ключа, носит название ведущей, а вторая модель в таком случае станет ведомой.
В отличие от связей описанных ранее типов, имя поля, образующего связь «многие-со-многими», рекомендуется записывать во множественном числе(spares). Что и логично - ведь такая связь позволяет связать произвольное количество записей, что называется, с обеих сторон. На уровне базы данных для представления связи такого типа создается таблица, по-умолчанию имеющая имя вида <псевдоним приложения>_<имя класса ведущей модели>_<имя класса ведомой модели> (связующая таблица). Она будет иметь ключевое поле id и по одному полю с именем вида <имя класса связываемой модели>_id на каждую из связываемых моделей. Так, в нашем случае будет создана связующая таблица с именем samplesite_machine_spare, имеющая поля id, machine_id и spare_id.
Если создается связь с той же самой моделью, связующая таблица будет иметь поля id, from_<имя класса модели>_id и to_<имя класса модели>_id.

Параметры:
symrnetrical - используется только в тех случаях, когда модель связывается сама с собой. Если True, Django создаст симметричную связь, действующую в обоих направлениях (применительно к нашему случаю: если какая-то деталь А входит в машину Б, то машина Б содержит деталь А). Если False, связь будет асимметричной (чисто гипотетически: какая-то деталь А входит в машину Б, однако машина Б не содержит деталь А). Значение по умолчанию - True.
through - класс модели, которая представляет связующую таблицу (связующая модель) либо в виде ссьmки на него, либо в виде имени, представленном строкой. Если он не указан, связующая таблица будет создана самим Django.
При использовании связующей модели нужно иметь в виду следующее, что поле внешнего ключа для связи объявляется и в ведущей, и в ведомой моделях. При создании этих полей следует указать как саму связующую модель (параметр through), так и поля внешних ключей, по которым будет установлена связь (параметр through_fields). В связующей модели следует явно объявить поля внешних ключей для установления связи с обеими связываемыми моделями: ведущей и ведомой.

--Миграции--
Миграция - это модуль Python, созданный самим Django на основе определенной модели и предназначенный для формирования в базе данных всех требуемых этой моделью структур: таблиц, полей, индексов, правил и связей.


--Шаблоны--
Шаблон - это образец для формирования документа, который будет представлен клиенту. Подсистема Django, называемая шаблонизатором, загружает шаблон, объединяет его с данными, извлеченными из моделей, полученными от посетителя или сгенерированными в процессе работы, и формирует на основе всего этого полноценный документ, который и отправляется клиенту. 

Применительно к веб-страницам, шаблон - это файл с НТМL-кодом страницы, содержащий особые команды шаблонизатора: директивы, теги и фильтры. Директивы указывают поместить в заданное место НТМL-кода какое-либо значение, теги управляют генерированием содержимого результирующего документа, а филътры выполняют какие-либо преобразования указанного значения перед выводом.

В шаблон можно добавлять переменные из разных моделей одновременно например из Bb и Rubric. В модели Bb есть параметр rubric, который является ForeignKey от Rubric. Таким образом можно получить доступ к параметрам Rubric через Bb - bb.rubric.name

----Наследование шаблонов----

Шаблон, являющийся базовым, объявляет в составе своего содержимого так называемые блоки. Они определяют место в шаблоне, куда будет вставлено содержимое, извлеченное из шаблонов, которые станут производными по отношению к базовому. Каждый из блоков имеет уникальное в пределах шаблона имя.

Объявленный в базовом шаблоне блок может быть как пустым:
	{% blосk content %}
	{% endblock %}

так и иметь какое-либо изначальное содержимое: 
	{% blосk title %}Главная{% endblock %}

Это содержимое будет присутствовать в блоке, если производный шаблон не задаст для него свое содержимое.

В производном шаблоне:
	{% extends "layout/basic.html" %}  
	{% blосk content %}
	...
	{% endblock %}
	
Путь к базовому шаблону указывается от папки templates. В данном примере файл basic.html находится в templates>layout>. Если бы файл находился в templates>bboard>layout>, то путь выглядел бы {% extends "bboard/layout/basic.html" %} 

	
--Формы--
Для ввода данных язык HTML предлагает так называемые веб-формы.
Объявляется класс формы, связанной с моделью. Такая форма «умеет» генерировать теги, что создадут входящие в состав формы элементы управления, проверять на корректность введенные данные и, наконец, сохранять их в модели, с которой она связана. 

Класс формы, связанной с моделью, является производным от класса Mode!Form из модуля django.forms. В классе формы вложенный класс Meta, в котором указываются параметры нашей формы: класс модели, с которой она связана (атрибут класса model), и последовательность из имен полей модели, которые должны присутствовать в форме (атрибут класса fields).

Обрабатывать формы, связанные с моделью, можно в знакомых нам контроллерах-функциях. Но также можно применять высокоуровневый контроллер-класс, который возьмет большую часть действий по выводу и обработке формы на себя - CreateView.

class BbCreateView(CreateView):
    template_name = 'bboard/create.html'
    form_class = BbForm
    success_url = '/bboard/'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['rubrics'] = Rubric.objects.all()
        return context
		
Контроллер-класс мы сделали производным от класса CreateView из модуля django.views.generic.edit. Базовый класс реализует функциональность по созданию формы, выводу ее на экран с применением указанного шаблона, получению занесенных в форму данных, проверке их на корректность, сохранению их в новой записи модели и перенаправлению в случае успеха на интернет-адрес, который мы зададим.

template_name - путь к файлу шаблона, который будет использован для вывода страницы с формой;
form_class - сам класс формы, связанной с моделью;
success_url - интернет-адрес, по которому будет выполнено перенаправление после успешного сохранения данных (в нашем случае это адрес главной страницы). 

В success_url можно вместо статического адреса записывать обратный интернет-адрес с помощью функции reverse_lazy().
Функция reverse_lazy() из модуля django.urls в качестве параметров принимает имя маршруrа и значения всех входящих в маршрут URL-параметров (если они там есть). Результатом станет готовый интернет-адрес. 

Метод get_context_data() нужен для того чтобы на страницу с формой вывести панель с рубриками.
Метод get_context_data() этого класса формирует контекст шаблона. Мы переопределили метод, чтобы добавить в контекст дополнительные данные - список
рубрик. В теле этого метода мы сначала получаем контекст шаблона от метода базового класса, затем добавляем в него список рубрик и, наконец, возвращаем
в качестве результата. 

В шаблоне формы:
	<form method="post">
		{% csrf_token %)
		{{ form.as_p ))
		<input type="submit" vаluе="Добавить">
	</form> 

- форма в контексте шаблона хранится в переменной form. Эту переменную создает базовый класс CreateView;
- в выводе формы, чтобы элементы управления находятся на отдельных абзацах, для переменной form применяется метод as_p() класса ModelForm ;
-  метод as_p() генерирует только код, создающий элементы управления. Тег <form>, необходимый для создания самой формы, и тег <input>, формирующий
кнопку отправки данных, добавляются самостоятельно.
- в теге <form> мы указали метод отправки данных POST, но не записали интернет-адрес, по которому будут отправлены занесенные в форму данные. В этом случае данные будут отправлены по тому же интернет-адресу, с которого была загружена текущая страница, т.е. в нашем случае, тому же контроллеру-классу BbCreateView, который благополучно обработает и сохранит их;
-  в теге <form> мы поместили тег шаблонизатора csrf_token. Он создает в форме скрытое поле, хранящее цифровой жетон, получив который, контроллер «поймет», что данные бьли отправлены с текущего сайта, и им можно доверять. Это часть подсистемы обеспечения безопасности Django.

В модуль urls добавляем путь:
	path('add/', BbCreateView.as_view(), name='add' ),
 
В вызов функции раth( ) в таком случае подставляется не ссылка на сам контроллер-класс, а результат, возвращенный методом as_view() контроллера-класса. 

















