--Представление(контроллер)--
Любой контроллер-функция в качестве единственного обязательного параметра принимает экземпляр класса HttpRequest, хранящий различные сведения о полученном запросе: запрашиваемый интернет-адрес, данные, полученные от посетителя, служебную информацию от самого веб-обозревателя и пр. По традиции этот параметр называется request. 

В теле функции экземпляр класса HttpResponse (он объявлен в модуле django.http) будет представлять отправляемый клиенту ответ. 


--Марштруты--
При поступлении любого запроса от клиента Django разбирает его на составные части (чем занимается целая группа программных модулей, называемых посредники), извлекает запрошенный посетителем интернет адрес, удаляет из него все составные части, за исключением пути, который передает маршрутизатору. Последний последовательно сравнивает его с шаблонными адресами, записанными в списке маршрутов. Как только будет найдено совпадение, маршрутизатор выясняет, какой контроллер связан с совпавшим шаблонным адресом, и передает этому контроллеру управление. 

----Параметризованные запросы----
Предположим нам нужно отфильтровывать из модели определенные записи(с определенным атрибутом), например название рубрики. Чтобы контроллер, который будет отфильтровывать из модели объявления, относящиеся к выбранной рубрике, смог, собственно, их отфильтровать, он должен получить ключ рубрики.

Этот ключ удобнее всего передать в составе интернет-адреса, через GЕТ-параметр: /bboard/?rubric=<ключ рубрики>. Однако Django предлагает нам другую возможность выполнить передачу параметров в контроллер - непосредственно в составе пути интернет-адреса: bboard/<ключ рубрики> 

Для этого нужно указать маршрутизатору, какую часть пути считать URL-параметром, каков тип этого параметра, и какое имя у параметра.
urlpatterns = [
	path( '<int:rubric_id>/', by_ruЬric),
]
<> - параметр указывается в угловых скобках
int - тип целое число 
rubric_id - имя параметра

Чтобы передать параметр контроллеру контроллер-функция должна иметь помимо атрибута request еще и этот атрибут
	def by_rubric(request, rubric_id):
	
----Обратное разрешение интернет-адресов----
Если мы решим изменить шаблонный интернет-адрес в списке маршрутов, нам придется вносить уйму правок и в код шаблонов. Существует инструмент Django, называемый обратным разрешением интернет-адресов. Его суть: мы указываем маршрут, формирующий нужный нам интернет-адрес(значения URL-параметров - если требуется), а Django сам генерирует на основе всего этого правильный интернет-адрес. 
Для этого нужно:
1. Дать маршрутам имена, создав тем самым именованные маршруты.
	path ( '<int: rubric_id>/', by_rubric, name='by_rubric'),

2. Использование в гиперссылках тегов шаблонизатор url. Имя маршрута указывается первым параметром. Значение URL-параметра - вторым.
	<а href="{% url 'by_rubric' rubric.pk %}">
	
ВНИМАНИЕ! С именованными параметрами нужно быть внимательным.
Если формируем ссыллку внутри цикла из модели Rubric, то обращаемся к параметру как rubric.pk:
{% for rubric in rubrics %}
    <a href="{% url 'by_rubric' rubric.pk %}">{{ rubric.name }}</a>	
А если формируем ссылку внутри цикла из модели Bb, то обращаться к параметру нужно уже как bb.rubric.pk:
{% for bb in bbs %}
    <p><a href="{% url 'by_rubric' bb.rubric.pk %}">{{ bb.rubric.name }}</a></p>


----Интернет-адрес модели и его формирование----
Django позволяет сформировать интернет-адрес, указывающий на конкретную запись модели, - интернет-адрес модели. По этому адресу может находиться страница с содержимым этой записи, списком связанных записей и др. Сформировать интернет-адрес модели можно двумя способами: декларативным и императивным.

Декларативный способ заключается в том, что мы описываем формат интернет-адреса в настройках проекта. Набор таких адресов оформляется в виде словаря Python и записывается в параметре ABSOLUTЕ_URL_OVERRIDES модуля settings.py пакета конфигурации.
Ключи элементов этого словаря должны иметь вид <псевдоним приложения>.<имя класса модели>. Значениями элементов станут функции, в качестве единственного параметра принимающие объект записи модели, а в качестве результата возвращающие строку с готовым интернет-адресом. Здесь удобно использовать лямбда-функции Python.
Пример объявления словаря, который на основе рубрики (экземпляра класса модели Rubric) сформирует интернет-адрес вида /bboard/<ключ рубрики>/, ведущий на страницу со списком относящихся к этой рубрике объявлений:
    AВSOLUTE_URL_OVERRIDES = {
        'bboard.rubric': lambda rec: "/bboard/%s/" % rec.pk,
        }
Теперь, чтобы поместить в код шаблона интернет-адрес модели, нам достаточно вставить туда вызов метода get_absolute_url(), унаследованного всеми моделями от базового класса Model:
    <а href="{{ rubric.get_absolute_url }}">{{ rubric.name }}</а>
Точно таким же образом можно получить интернет-адрес модели где-либо еще -например, в коде контроллера.

Императивный способ заключается в непосредственном переопределении метода get_absolute_url() в классе модели. Вот пример:
    class Rubric(models.Model):
        def get_absolute_url(self):
            return "/bboard/%s/" % self.pk
Разумеется, в параметре AВSOLUTE_URL_OVERRIDES настроек проекта в таком случае нет нужды.

--Модель--
Модель - это описание сущности, хранящейся в базе данных в виде класса Python. Класс модели описывает таблицу базы данных,в которой будет храниться набор сущностей, и атрибуты класса, каждый из которых описывает одно из полей таблицы. Можно сказать, что модель это представление таблицы и ее полей средствами Python. 
Отдельный экземпляр класса модели представляет отдельную конкретную сущность, извлеченную из базы, т. е. отдельную запись соответствующей таблицы.
Пользуясь объявленными в модели атрибутами класса, мы можем получать значения, хранящиеся в полях записи, равно как и записывать в них новые значения. 

Все классы моделей поддерживают атрибут класса objects. Он хранит диспетчер записей - особую структуру, позволяющую манипулировать всей совокупностью имеющихся в модели записей. Диспетчер записей представляется экземпляром класса Manager.

По поводу низкоуровневых структур, создаваемых в базе данных и используемых моделью для хранения сущностей, можно отметить следующее:
- каждая модель представляет отдельную таблицу в базе данных;
- по умолчанию таблицы, представляемые моделями, получают имена вида <псевдоним приложения>_<имя класса модели> (в данном случае будет bboard_bb);
- каждое поле модели представляет отдельное поле в соответствующей таблице базы данных;
- по умолчанию поля в таблице получают имена, совпадающие с именами полей модели, которые их представляют(в данном случае  title, content, price ...);
- если в модели не было явно объявлено ключевое поле для хранения значения, однозначно идентифицирующего запись модели (ключа), оно будет создано самим фреймворком, получит имя id, целочисленный тип, будет помечено как автоинкрементное, и для него будет создан ключевой индекс;
- по умолчанию никакие дополнительные индексы в таблице не создаются.

Модель может быть создана для представления как уже существующей в базе таблицы (в этом случае при объявлении модели нам придется дополнительно указать
имя таблицы и имена всех входящих в нее полей), так и еще не существующей (тогда для создания таблицы нам нужно сгенерировать миграцию).


Метод create () диспетчера записей создает новую запись модели, принимая в качестве набора именованных параметров значения ее полей. При этом он сразу же сохраняет созданную запись и возвращает ее в качестве результата. 

Метод all ( ) диспетчера записей возвращает набор записей. Сам набор записей представляется экземпляром класса Queryset, а отдельные записи - экземплярами соответствующего класса модели. Поскольку набор записей является последовательностью и поддерживает итерационный протокол, мы можем перебрать его в цикле. 

Метод order_Ьу ( ) диспетчера записей сортирует записи по значению поля, чье имя указано в параметре.(for Ь in Bb.objects.order_by('title'))
Метод filter () диспетчера записей выполняет фильтрацию записей по заданным критериям.(for Ь in Bb.objects.filter(title='Дoм'))
Метод get ( ) диспетчера записей имеет то же назначение, что и метод fi1ter( ), и вызывается аналогичным образом. Однако он ищет не все записи, подходящие под заданные критерии, а лишь одну и возвращает ее в качестве результата. К тому же, он работает быстрее метода filter(). 


Вложенный класс Mеtа содержит атрибуты класса, которые задают параметры самой модели:
verbose_name_plural - название набора сущностей, хранящихся в модели, которая будет выводиться на экран;
verbose_name - название сущности, хранящейся в модели, которое будет выводиться на экран.
Эти названия также будут выводиться на экран в админке сайта.
ordering - последовательность полей, по которым по умолчанию будет выполняться сортировка записей. 
order_with_respect_to = 'rubric' - позволяет сделать набор записей произвольно упорядочиваемым. В качестве значения параметра задается строка с именем поля текущей модели, и в дальнейшем записи, в которых это поле хранит одно и тоже значение, могут быть упорядочены произвольным образом. При указании в модели этого параметра в таблице будет дополнительно создано поле с именем вида <имя поля, заданного в качестве значения параметра>_оrdеr. Оно будет хранить целочисленное значение, указывающее порядковый номер текущей записи в последовательности. Одновременно вновь созданное поле с порядковым номером будет задано в качестве значения параметра ordering (см. ранее). Следовательно, записи, которые мы извлечем из модели, по умолчанию будут отсортированы по значению этого поля. Указать другие параметры сортировки в таком случае будет невозможно.
unique together - последовательность имен полей, представленных в виде строк, которые должны хранить уникальные в пределах таблицы комбинации
значений. 
    class Meta:
        unique_together = (
            ('title', 'published'),
            ('title', 'price', rubric),
            )
Теперь комбинация названия товара и даты публикации объявления должна быть уникальной в пределах модели. Тоже самое для комбинации названия, цены и рубрики.

Помимо атрибутов класса, представляющих поля модели, и вложенного класса меtа, где объявляются параметры модели, мы можем объявить в классе модели дополнительные методы:

__str__() - представление будет выводиться, если в коде шаблона указать вывод непосред­ственно объекта записи, а не значения его поля или результата, возвращенного его методом:
	{{ rubric }}

save() - выполняет сохранение записи. При определении этого метода обяза­тельно следует вставить в нужное место кода вызов метода, унаследованного от базового класса. Вот пример:
    def save(self, *args, **kwargs):
        # Выполняем какие-либо действия
        # Выполняем сохранение записи, только если метод is_model_correct() вернет True
	if self.is_model_correct():
            super().save(*args, **kwargs)  # Сохраняем запись вызвав, унаследованный метод.
        # Выполняем какие-либо действия после сохранения.

Мы можем, в зависимости от выполнения или невыполнения какого-то условия, отменить сохранение записи, для чего достаточно просто не вызывать унаследованный метод save()

delete() - выполняет удаление записи. Этот метод также переопределяется для добавления какой-либо логики, что должна выполняться перед и (или) после удаления.

Мы можем создать в модели дополнительное поле, значение которого вычисляется на основе каких-то других данных и которое доступно только для чтения (функцио­нальное поле). Для этого достаточно объявить метод, не принимающий параметров и возвращающий нужное значение. Имя этого метода станет именем функциональ­ного поля. 
    class Bb(models.Model):
	...
        def title_and_price(self):
            if self.price:
                return '%s (%.2f)' % (self .title, self.price)
            else:
                return self.title
	...
	title_and_price.short_description = 'Название и цена' # название, которое будет выводить­
ся на страницах сайта, в качестве заголовка столбца или надписи для элемен­та управления.


Параметры поддерживаемые всеми типами полей:
- verbose_name указывает "человеческое" название поля, которое будет выводиться на экран на страницах административного сайта и напротив элементов управления в веб-формах. Если оно не указано, в таковом качестве будет использовано имя поля.
- help_text - дополнительный поясняющий текст, выводимый на экран. Значение по умолчанию - пустая строка. 
- unique - если True, в текущее поле может быть занесено только уникальное в пределах таблицы значение (уникальное поле). При попытке занести значение, уже имеющееся в том же поле другой записи, будет возбуждено исключение IntegrityError из модуля django.db. Если поле помечено как уникальное, по нему автоматически будет создан индекс. Поэтому явно задавать для него индекс не нужно. 
- null - если True, поле в таблице базы данных может хранить значение null и, таким образом, являться необязательным к заполнению. Параметр null затрагивает только поле таблицы, но не поведение Django. Даже если какое-то поле присвоением параметру значения тrue было помечено как необязательное, фреймворк по умолчанию все равно не позволит занести в него пустое значение;
-blank - если тrue, Django позволит занести в поле пустое значение, тем самым сделав поле необязательным к заполнению. Параметр blank задает поведение самого фреймворка при выводе на экран веб-форм и проверке введенных в них данных. Если для этого параметра бьmо указано значение true, Django позволит занести в поле пустое значение (например, для строкового поля - пустую строку), даже если это поле было помечено как обязательное к заполнению (параметру null было дано значение False);
- choices - последовательность значений, доступных для занесения в текущее поле. Может быть использован для создания полей, способных хранить ограниченный набор значений, которые посетитель выбирает из списка(поле со списком). Если значение поля должно быть текстовым, то и значение 1-го элемента должно быть текстовое и т.д.

class Bb(models.Model):
КINDS = (
( 'b', 'Куплю'),
( 's' , ' Продам' ) ,
( 'с' , 'Обменяю' ) ,
)

kind = models.CharField(max_length=l, choices=KINDS) 

- db_index - если True, по текущему полю в таблице будет создан индекс, если False - не будет. Значение по умолчанию- False;
- primary_key - если True, текущее поле станет ключевым. При этом ключевое поле будет помечено как обязательное к заполнению и уникальное (параметру null неявно будет присвоено значение False, а параметру unique - True).

----Редактор модели в админке сайта----
На странице списка записей в админке все позиции представляются невразумительными строками вида <имя класса модели> object (<значение ключа>)" из которых невозможно понять, что же хранится в каждой из этих записей. Но можно вывод данной информации редактировать.

В admin.py создаем редактор модели, который объявляется как подкласс admin.ModelAdmin и с помощью атрибута list_display указываем какие поля записи должны отображаться. 
list_display_links - создает ссылку на редактирование записи,
search_fields - добавляет поле для поиска.

class BbAdmin(admin.ModelAdmin):
	list_display = ('title', 'content', 'price', 'published')
	list_display_links = ('title', 'content')
	search_fields = ('title', 'content',)
admin.site.register(Bb, BbAdmin) 

Этот способ лучше всего подходит только для моделей с несколькими значащими полями, если же такое поле в модели всего одно, проще переопределить метод __str__ в самой модели.

class Rubric(models.Model):
	def __str__(self) :
		return self.name 


----Связь между моделями----

"один со многими"
Для связи между моделями во вторичную модель добавляется внешний ключ, устанавливающий связь между этой модель и записью первичной модели. Таким образом будет создана связь "один со многими".

rubric = models.ForeignKey('Rubric', null=Тrue, on_delete=models.PROTECT, vеrbоsе_name='Рубрика')

Первым параметром:
- Rubric - ссылка на класс - если код, объявляющий класс первичной модели, располагается перед кодом класса вторичной модели; 
- 'Rubric' - строки с именем класса - если вторичная модель объявлена раньше первичной
- Если необходимо передать ссылку на модель, объявленную в другом приложении проекта, необходимо использовать строку формата <имя прwюжения>.<имя класса модели>: 'rubrics.Rubric'
- Если нужно создать модель, ссылающуюся на себя (создать рекурсивную связь), первым параметром конструктору следует передать строку 'self'. 

null=Тrue Все поля, создаваемые в моделях, по умолчанию обязательны к заполнению. Следовательно, добавить новое, обязательное к заполнению поле в модель, которая
уже содержит записи, нельзя - сама СУБД откажется делать это и выведет сообщение об ошибке. Нам придется явно пометить поле ruЬric как необязательное,
присвоив параметру null значение true - только после этого поле будет успешно добавлено в модель. 

Параметр on_delete управляет каскадными удалениями записей вторичной модели после удаления записи первичной модели, с которой они были связаны.
- CASCADE - удаляет все связанные записи вторичной модели (каскадное удаление); 
- РRОТЕСТ - возбуждает исключение ProtectedError из модуля django.db.models, тем самым предотвращая удаление записи первичной модели;
- SET_NULL - заносит в поле внешнего ключа всех связанных записей вторичной модели значение null. Сработает только в том случае, если поле внешнего ключа объявлено необязательным к заполнению на уровне базы данных (параметр null конструктора поля имеет значение True);
- SET_DEFAULT- заносит в поле внешнего ключа всех связанных записей вторичной модели заданное для него значение по умолчанию. Сработает только в том
случае, если у поля внешнего ключа бьmо указано значение по умолчанию (оно задается параметром default конструктора поля);
- SET (<значение>) - заносит в поле внешнего ключа указанное значение

Параметр limit_choices_to - позволяет вывести в списке связываемых записей первичной модели только те, что удовлетворяют заданным критериям фильтрации. 
Для примера укажем Django выводить только рубрики, поле visible которых содержит значение тrue:
	rubric = models.ForeignКey(Rubric, on_delete=models.PROTECT, limit_choices_to={'visible': True}) 

Параметр related_name - для доступа к записям вторичной модели через значение атрибута записи первичной модели.
	class Bb(models.Model):
		rubric = models.ForeignKey(Rubric, on_delete=models.PROTECT,related_name='entries')

# Получаем первую рубрику
first_rubric = Rubric.objects.first()
# Получаем доступ к связанным объявлениям через атрибут entries, указанный в параметре related_name
bbs = first_rubric.entries.all() 

Создание записи вторичной модели.
- Мы можем присвоить полю внешнего ключа непосредственно объект, представляющий связываемую запись первичной модели. Пример:
	>>> r = Rubric.objects.get(name='Meбeль')
	>>> r
	<Rubric: Мебель>
	>>> b = Вb()
	>>> b.title = 'Диван'
	>>> b.contents = 'Продавленный'
	>>> b.price = 100
	>>> b.ruЬric = r
	>>> b.save() 
	
- Через атрибут первичной таблицы с именем вида <имя связанной вторичной модели>_set.(Он хранит экземпляр класса RelatedManager из модуля django.dЬ.models.fields.related, представляющий набор связанных записей вторичной таблицы) и называется диспетчером обратной связи.
ВНИМАНИЕ! Имя <имя связанной вторичной модели_set> по умолчанию. Однако это имя можно изменить, при объявлении поля внешнего
ключа указав его в параметре related_name конструктора класса поля

Класс RelatedManager поддерживает два очень полезных метода:
- add (<связываемая запись 1>, <связываемая запись 2> . . . <связываемая запись n>[, bulk=TrueJ) - связывает с текущей записью первичной модели записи вторичной модели, переданные в качестве параметров. 

	>>> r = Rubric.objects.get(name='Ceльxoзинвeнтapь')
	>>> Ь = Bb.objects.get(pk=24)
	>>> r.bb_set.add(b)
	>>> b.ruЬric
	<RuЬric: Сельхозинвентарь>
- create () - унаследован от класса Manager и, помимо создания записи вторичной модели, также выполняет ее связывание с текущей записью  первичной модели:
	>>> Ь2 = r.bb_set.create(title='Лoпaтa', price=lO)
	>>> b2.ruЬric
	<RuЬric: Сельхозинвентарь> 


"один-с-одним"
Связь «один-с-одним» соединяет одну запись первичной модели с одной записью вторичной модели. Такие связи служат для объединения моделей, одна из которых хранит данные, дополняющие данные из другой модели. Такая связь создается в классе вторичной модели объявлением поля типа OnetoOneField. Вот формат конструктора этого класса:
	ОnеТоОnеFiеld(<связываемая первичная модель>, оn_dеlеtе=<поведение при удалении записи>[,
<остальные параметры>])

В записи вторичной модели мы можем установить связь с записью первичной модели, присвоив последнюю полю внешнего ключа первой. 

	>>> from django.contrib.auth.models import User
	>>> from testapp.models import AdvUser
	>>> u = User.objects.get(username='admin')
	>>> au = AdvUser.objects.create(user=u)
	>>> au.user
	<User: admin>
	>>> u.advuser
	<AdvUser: AdvUser object (1)> 

Первичная модель при этом получит атрибут, хранящий связанную запись вторичной модели. Имя этого атрибута совпадет с именем вторичной модели. Следовательно, мы можем связать запись первичной модели с записью вторичной модели, также присвоив последнюю описанному ранее атрибуту.
	>>> au2 = AdvUser.objects.get(pk=2)
	>>> u.advuser = au2


"многие-со-многими"
Эта связь позволяет связать произвольное количество записей одной модели с произвольным количеством записей другой (обе модели здесь выступают как равноправные, и определить, какая из них первичная, а какая вторичная, не представляется возможным). Для создания такой связи нужно объявить в одной из моделей (но не в обеих сразу!) поле внешнего ключа типа ManyТoManyField. Вот формат его конструктора:
	ManyТoManyField(<втopaя связываемая модель > [<остальные параметры>])

Модель, в которой было объявлено поле внешнего ключа, носит название ведущей, а вторая модель в таком случае станет ведомой.
В отличие от связей описанных ранее типов, имя поля, образующего связь «многие-со-многими», рекомендуется записывать во множественном числе(spares). Что и логично - ведь такая связь позволяет связать произвольное количество записей, что называется, с обеих сторон. На уровне базы данных для представления связи такого типа создается таблица, по-умолчанию имеющая имя вида <псевдоним приложения>_<имя класса ведущей модели>_<имя класса ведомой модели> (связующая таблица). Она будет иметь ключевое поле id и по одному полю с именем вида <имя класса связываемой модели>_id на каждую из связываемых моделей. Так, в нашем случае будет создана связующая таблица с именем samplesite_machine_spare, имеющая поля id, machine_id и spare_id.
Если создается связь с той же самой моделью, связующая таблица будет иметь поля id, from_<имя класса модели>_id и to_<имя класса модели>_id.

Параметры:
symrnetrical - используется только в тех случаях, когда модель связывается сама с собой. Если True, Django создаст симметричную связь, действующую в обоих направлениях (применительно к нашему случаю: если какая-то деталь А входит в машину Б, то машина Б содержит деталь А). Если False, связь будет асимметричной (чисто гипотетически: какая-то деталь А входит в машину Б, однако машина Б не содержит деталь А). Значение по умолчанию - True.
through - класс модели, которая представляет связующую таблицу (связующая модель) либо в виде ссьmки на него, либо в виде имени, представленном строкой. Если он не указан, связующая таблица будет создана самим Django.
При использовании связующей модели нужно иметь в виду следующее, что поле внешнего ключа для связи объявляется и в ведущей, и в ведомой моделях. При создании этих полей следует указать как саму связующую модель (параметр through), так и поля внешних ключей, по которым будет установлена связь (параметр through_fields). В связующей модели следует явно объявить поля внешних ключей для установления связи с обеими связываемыми моделями: ведущей и ведомой.

В случае связей «один-со-многими» и «один-с-одним» поле внешнего ключа, объявленное во вторичной модели, всегда хранит непосредственно объект первичной модели, представляющий связанную запись. Но в случае связи «многие-со-многими» это не так- атрибут, представляющий поле, хранит экземпляр класса RelatedМanager - диспетчер обратной связи. Значит для организации связей можно пользоваться его методами:
add() - для добавления указанных записей в число связанных с текущей записью:
	>>> from testapp.models import Spare, Machine
	>>> s1 = Spare.objects.create(name='Бoлт')
	>>> s2 = Spare.objects.create(name='Гaйкa')
	>>> sЗ = Spare.objects.create(name='Шaйбa')
	>>> s4 = Spare.objects.create(name='Шпилькa')
	>>> m1 = Machine.objects.create(name='Caмocвaл')
	>>> m2 = Machine.objects.create(name='Tenлoвoз')
	>>> m1.spares.add(s1, s2)
	>>> m1. spares.all()
	<QuerySet [<Spare: Spare object (1)>, <Spare: Spare object (2)>]>
	>>> s1.machine_set.all()
	<QuerySet [<Machine: Machine object (1)>]>
	>>> m1.spares.add(s4)
	>>> m1.spares.all()
	<QuerySet [<Spare: Spare object (1)>, <Spare: Spare object (2)>, <Spare: Spare object (4)>]>

create () - для создания новых записей связанной модели и одновременного связывания их с текущей записью:
	>>> m1.spares.create(name='Bинт')
	<Spare: Spare object (5)>
	>>> m1.spares.all()
	<QuerySet [<Spare: Spare object (1)>, <Spare: Spare object (2)>, <Spare: Spare object (4)>, <Spare: Spare object (5)>]> 

set() - тоже самое, что и add(), но не добавляет указанные записи в число связанных с текущей записью, а заменяет ими те, что были связаны с ней ранее.
remove() - удаляет указанные записи из списка связанных с текущей записью
clear() - полностью очищает список записей, связанных с текущей. 



----Валидация модели----
Валидацией называется проверка на корректность данных, занесенных в поля модели. Мы можем реализовать валидацию непосредственно в модели или же в форме, которая используется для занесения в нее данных.

Валидацию значений, заносимых в отдельные поля модели, выполняют валидаторы, которые могут быть реализованы в виде функций или классов. Некоторые типы полей уже используют определенные валидаторы - так, строковое поле CharField задействует валидатор MaxLengthValidator, проверяющий, не превышает ли длина заносимого строкового значения указанную максимальную длину.
Помимо этого, мы можем указать для любого поля другие валидаторы, предоставляемые Django. 

Стандартные валидаторы Django.
Реализующие их классы объявлены в модуле django.core.validators. А указываются они в параметре validators конструктора класса поля.

Пример:
from django.core import validators
	class Bb(models.Model):
		title = models.CharField(max length=50, validators=[validators.RegexValidator(regex='л.{4, }$') ])
Regexvalidator - проверяет заносимое в поле значение на соответствие заданному регулярному выражению. 
MinLengthValidator - проверяет, не меньше ли длина заносимой строки заданного в первом параметре минимума.
MaxLengthValidator - проверяет, не превышает ли длина заносимой строки заданный в первом параметре максимум.
Email Validator - проверяет на корректность заносимый в поле адрес электронной почты. Используется полем типа EmailField.
URLValidator - проверяет на корректность заносимый в поле интернет-адрес. Используется полем типа URLField. 
ProhiЬitNullCharactersValidator - проверяет, не содержит ли заносимая строка нулевой символ: \хОО.
MinValueValidator - проверяет, не меньше ли заносимое число заданного в первом параметре минимума.(аналогично MaxValueValidator)

Часть валидаторов реализована в виде функций:
- validate_ipv46_address() - проверяет на корректность интернет-адреса протоколов IPv4 и IPv6;
- validate_ipv4_address() - проверяет на корректность интернет-адреса только протокола IPv4;
- validate_ipvб_address() - проверяет на корректность интернет-адреса только протокола IPv6.
Эти три валидатора используются полем типа GenericIPAddressField.

Во многих случаях стандартные сообщения об ошибках, выводимые валидаторами, вполне понятны. Но временами возникает необходимость указать для какого-либо поля свои сообщения.

	from django.core import validators

		class Bb(models.Model):
			title = rnodels.CharField(rnax_length=50, verbose_narne='Toвap',
validators=[validators.RegexValidator(regex='л.{4,)$')],
error_rnessages={'invalid': 'Неправильное название товара'}) 

Написание своих валидаторов.
Если нужный нам валидатор отсутствует в стандартном наборе, мы можем напи­сать его самостоятельно. У нас даже есть выбор - мы можем реализовать валидатор в виде функции или класса.

Валидатор, выполненный в виде функции, должен принимать один параметр-значение, которое следует проверить. Если значение некорректно, функция должна возбудить исключение ValidationError из модуля django.core.exceptions. Возвращать результат она не должна.
	from django.core.exceptions import ValidationError

	def validate_even(val):
		if val%2 != О:
			raise ValidationError('Чиcлo %(value)s нечетное', code='odd', params={ 'value': val))

Указываем валидатор для поля точно таким же образом, как указывали стандартный:
	class Bb(models.Model):
		...
		price = models.FloatField(validators=[validate_even])

Если валидатору при создании следует передавать какие-либо параметры, задаю­щие режим его работы, этот валидатор нужно реализовать в виде класса. Парамет­ры валидатору будут передаваться через конструктор класса, а сама валидация станет выполняться в переопределенном методе __саll__().
	from django.core.exceptions import ValidationError

	class MinМaxValueValidator:
		def __init__(self, min_value, max_value):
			self.min_value = min_value
			self.max_value = max_value
		def __call__(self, val) :
			if val < self.min_value or val > self.max_value:
				raise ValidationError('Bвeдeннoe число должно ' +'находиться в диапазоне от %(min )s до %(max)s', code='out_of_range', params={'min': self.min_value, 'max': self.max_value})


Может возникнуть необходимость проверить на корректность не значение одного поля, а всю модель (выполнив валидацию модели). Мы можем с легостью сделать это, переопределив в классе модели метод clean().
Метод не должен принимать параметры и возвращать результат. Единственное, что он обязан сделать, в - случае необходимости возбудить исключение ValidationError. Поскольку некорректные значения могут быть занесены сразу в несколько полей, нам придется формировать целый список ошибок.

Для примера давайте сделаем так, чтобы занесение описания продаваемого товара было обязательным, и предотвратим ввод отрицательного значения цены (разуме­ется, это проще сделать, задав соответствующие значения параметров у конструкторов полей, но давайте попрактикуемся в валидации модели).

	class Bb(models.Model):
		def clean(self):
			errors = {}
			if not self.content:
				errors['content'] = ValidationError('Yкaжитe описание продаваемого товара')
			if self.price and self.price < О:
				error['price'] = ValidationError('Укaжитe неотрицательное значение цены')
			if errors:
				raise ValidationError(errors)

Если нам нужно вывести какое-либо сообщение об ошибке, относящейся не к определенному полю модели, а ко всей модели, следует использовать в качестве ключа словаря, хранящего список ошибок, значение переменной NON_FIELD_ERRORS из модуля django.core.exceptions. 
Пример:
	from django.core.exceptions import NON_FIELDS_ERRORS
	...
	errors[NON_FIELDS_ERRORS] = ValidationError('Oшибкa в модели!')


--Миграции--
Миграция - это модуль Python, созданный самим Django на основе определенной модели и предназначенный для формирования в базе данных всех требуемых этой моделью структур: таблиц, полей, индексов, правил и связей.

Для формирования миграций служит команда makemigrations:
manage.py makemigrations [<список псевдонимов приложений, разделенных пробелами>] [--name|-n <имя миrрации>] [--noinput] [--no-input] [--dry-run] [--check] [--merge] [--empty]

Django отслеживает любые изменения в коде моделей, даже те, которые не затраги­вают структуры базы данных напрямую. Так, если мы укажем для поля модели назва­ние (параметр verbose_name конструктора поля), фреймворк все равно создаст в миграции код, который изменит параметры нижележащего поля таблицы в базе данных. Поэтому крайне желательно продумывать структуру моделей заранее и впоследствии, по возможности, не менять ее.

В процессе выполнения миграций в базе данных создаются или изменяются ниже­лежащие структуры. Выполнение запускается командой migrate утилиты manage.py:
	manage. ру migrate [<псевдоним приложения> [<имя миграции>] ][--fake-initial] [--noinput] [--no-input] [--fake]
Если не указывать ни псевдоним приложения, ни имени миграции, будут выполнены все невыполненные к настоящему моменту миграции во всех приложениях проек­та. Если указать только псевдоним приложения, будут выполнены все миграции в этом приложении, а если дополнительно задать имя миграции, будет выполнена только эта миграция.
Задавать имя модуля миграции полностью нет необходимости - достаточно записать только находящийся в начале ее имени порядковый номер:
	manage.py migrate bboard 0001

Если в модели неоднократно вносились изменения, после чего выполнялось гене­рирование миграций на основе исправленных моделей, таких миграций может накопиться довольно много. Чтобы уменьшить их количество и заодно ускорить процесс их применения к "свежей" базе данных, рекомендуется выполнить слияние миграций.
	manage.ру squashmigrations <псевдоним приложения> [<имя последней миграции>] [<имя последней миграции>] [ --squashed_name <имя результирующей миграции>] [--no-optimize] [--noinput] [--no-input]

Обязательными для указания являются только псевдоним приложения и имя послед­ней миграции.

Вывод всех миграций
	manage.py showmigrations [<список псевдонимов приложений, разделенных пробелами>] [ --plan] [ -р]

Отмена всех миграций
	manage.py migrate <псевдоним приложения> zero
К сожалению, отменить отдельную, произвольно выбранную миграцию невоз­можно.


--Шаблоны--
Шаблон - это образец для формирования документа, который будет представлен клиенту. Подсистема Django, называемая шаблонизатором, загружает шаблон, объединяет его с данными, извлеченными из моделей, полученными от посетителя или сгенерированными в процессе работы, и формирует на основе всего этого полноценный документ, который и отправляется клиенту. 

Применительно к веб-страницам, шаблон - это файл с НТМL-кодом страницы, содержащий особые команды шаблонизатора: директивы, теги и фильтры. Директивы указывают поместить в заданное место НТМL-кода какое-либо значение, теги управляют генерированием содержимого результирующего документа, а филътры выполняют какие-либо преобразования указанного значения перед выводом.

В шаблон можно добавлять переменные из разных моделей одновременно например из Bb и Rubric. В модели Bb есть параметр rubric, который является ForeignKey от Rubric. Таким образом можно получить доступ к параметрам Rubric через Bb - bb.rubric.name

----Наследование шаблонов----

Шаблон, являющийся базовым, объявляет в составе своего содержимого так называемые блоки. Они определяют место в шаблоне, куда будет вставлено содержимое, извлеченное из шаблонов, которые станут производными по отношению к базовому. Каждый из блоков имеет уникальное в пределах шаблона имя.

Объявленный в базовом шаблоне блок может быть как пустым:
	{% blосk content %}
	{% endblock %}

так и иметь какое-либо изначальное содержимое: 
	{% blосk title %}Главная{% endblock %}

Это содержимое будет присутствовать в блоке, если производный шаблон не задаст для него свое содержимое.

В производном шаблоне:
	{% extends "layout/basic.html" %}  
	{% blосk content %}
	...
	{% endblock %}
	
Путь к базовому шаблону указывается от папки templates. В данном примере файл basic.html находится в templates>layout>. Если бы файл находился в templates>bboard>layout>, то путь выглядел бы {% extends "bboard/layout/basic.html" %} 

	
--Формы--
Для ввода данных язык HTML предлагает так называемые веб-формы.
Объявляется класс формы, связанной с моделью. Такая форма «умеет» генерировать теги, что создадут входящие в состав формы элементы управления, проверять на корректность введенные данные и, наконец, сохранять их в модели, с которой она связана. 

Класс формы, связанной с моделью, является производным от класса Mode!Form из модуля django.forms. В классе формы вложенный класс Meta, в котором указываются параметры нашей формы: класс модели, с которой она связана (атрибут класса model), и последовательность из имен полей модели, которые должны присутствовать в форме (атрибут класса fields).

Обрабатывать формы, связанные с моделью, можно в знакомых нам контроллерах-функциях. Но также можно применять высокоуровневый контроллер-класс, который возьмет большую часть действий по выводу и обработке формы на себя - CreateView.

class BbCreateView(CreateView):
    template_name = 'bboard/create.html'
    form_class = BbForm
    success_url = '/bboard/'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['rubrics'] = Rubric.objects.all()
        return context
		
Контроллер-класс мы сделали производным от класса CreateView из модуля django.views.generic.edit. Базовый класс реализует функциональность по созданию формы, выводу ее на экран с применением указанного шаблона, получению занесенных в форму данных, проверке их на корректность, сохранению их в новой записи модели и перенаправлению в случае успеха на интернет-адрес, который мы зададим.

template_name - путь к файлу шаблона, который будет использован для вывода страницы с формой;
form_class - сам класс формы, связанной с моделью;
success_url - интернет-адрес, по которому будет выполнено перенаправление после успешного сохранения данных (в нашем случае это адрес главной страницы). 

В success_url можно вместо статического адреса записывать обратный интернет-адрес с помощью функции reverse_lazy().
Функция reverse_lazy() из модуля django.urls в качестве параметров принимает имя маршруrа и значения всех входящих в маршрут URL-параметров (если они там есть). Результатом станет готовый интернет-адрес. 

Метод get_context_data() нужен для того чтобы на страницу с формой вывести панель с рубриками.
Метод get_context_data() этого класса формирует контекст шаблона. Мы переопределили метод, чтобы добавить в контекст дополнительные данные - список
рубрик. В теле этого метода мы сначала получаем контекст шаблона от метода базового класса, затем добавляем в него список рубрик и, наконец, возвращаем
в качестве результата. 

В шаблоне формы:
	<form method="post">
		{% csrf_token %)
		{{ form.as_p ))
		<input type="submit" vаluе="Добавить">
	</form> 

- форма в контексте шаблона хранится в переменной form. Эту переменную создает базовый класс CreateView;
- в выводе формы, чтобы элементы управления находятся на отдельных абзацах, для переменной form применяется метод as_p() класса ModelForm ;
-  метод as_p() генерирует только код, создающий элементы управления. Тег <form>, необходимый для создания самой формы, и тег <input>, формирующий
кнопку отправки данных, добавляются самостоятельно.
- в теге <form> мы указали метод отправки данных POST, но не записали интернет-адрес, по которому будут отправлены занесенные в форму данные. В этом случае данные будут отправлены по тому же интернет-адресу, с которого была загружена текущая страница, т.е. в нашем случае, тому же контроллеру-классу BbCreateView, который благополучно обработает и сохранит их;
-  в теге <form> мы поместили тег шаблонизатора csrf_token. Он создает в форме скрытое поле, хранящее цифровой жетон, получив который, контроллер «поймет», что данные бьли отправлены с текущего сайта, и им можно доверять. Это часть подсистемы обеспечения безопасности Django.

В модуль urls добавляем путь:
	path('add/', BbCreateView.as_view(), name='add' ),
 
В вызов функции раth( ) в таком случае подставляется не ссылка на сам контроллер-класс, а результат, возвращенный методом as_view() контроллера-класса. 


--Создание записей--
Создать новую запись в модели можно тремя способами:
- создать новый экземпляр класса модели, не передавая конструктору никаких параметров, занести в поля нужные значения.
	from bboard.models import Rubric
	>>> r = Rubric()
	>>> r.name = 'Бытовая техника'
	>>> r. save ()
- создать новый экземпляр класса модели, указав значения полей непосредственно в вызове конструктора - через одноименные параметры.
	>>> r = Rubriс(nаmе='Сельхозинвентарь')
	>>> r.save()
Оба способа требуют метод save() для сохранения в базе.
- через диспетчер записей
	>>> r = Rubric.objects.create(name='Meбeль')
Данный способ сразу добавляет запись в базу.

При создании новой записи любым из описанных ранее способов Django проверяет значение ее ключевого поля. Если таковое хранит пустую строку или None (т.е. ключ отсутствует), фреймворк вполне резонно предполагает, что запись нужно добавить в базу, и выполняет ее добавление посылкой СУБД SQL-команды INSERT.  

Метод get_or_create(<набор фильтров>[, deafults=None]) - выполняет поиск на основе заданнных фильтров и если не находит, то создает запись. Возвращает 2 параметра(первый - запись, второй - True(если запись создана), False(если запись найдена))
	>>> r = Rubric.objects.get_or_create(name='Meбeль')
	>>> r
	(<Rubric: Мебель>, False)

Метод update_or_create(<нaбop фильтров>[, defaults=None]) - аналогичен методу get_or_create(), но в случае, если запись найдена, заносит в ее поля новые значения, заданные в словаре, который присвоен параметру defaults. Пример:
	>>> Rubric.objects.update_or_create(name='Цвeты', defaults= { 'name' : 'Растения' })
	(<RuЬric: Растения>, False) 

----Массовая запись данных----
Если возникает необходимость создать, исправить или удалить сразу большое количество записей, удобнее использовать средства Django для массовой записи данных. Это следующие методы класса Manager (они также поддерживаются производным от него классом RelatedManager):

- bulk_create (<последовательность добавляемых записей>[, batch_size=None]) - добавляет в модель записи, указанные в последовательности.
Параметр Ьatch_size задает количество записей, которые будут добавлены в одной SQL-команде. Если он не указан, все заданные записи будут добавлены в одной команде (поведение по умолчанию). 

	>>> r = Rubric.objects.get(name='Бытoвaя техника')
	>>> Bb.objects.bulk_create([
		Bb(title='Пылесос', content='Хороший, мощный', price=1000, rubric=r),
		Bb(title='Стиральная машина', content='Автоматическая', price=3000, rubric=r)
		])
- update (<новые значения полей>) - исправляет все записи в наборе, задавая для них новые значения полей. Эти значения задаются для параметров метода, чьи имена совпадают с именами нужных полей модели.
	>>> Bb.objects.filter(price=None).update(price=1O)

- delete() - удаляет все записи в наборе. Аналогично update().

Методы для массовой записи данных работают быстрее, чем программные инструменты моделей, поскольку напрямую «общаются» с базой данных. Однако при их использовании программные инструменты, определенные в моделях (в частности, автоматическое получение ключей записей и выполнение методов save() и delete()), не работают. 


--Выборка данных--
- Извлечение значений из полей записи:
	>>> b = Bb.objects.get(pk=1)
	>>> b.title
	'Дача' 
Атрибут класса pk хранит значение ключа для текущей записи.

- Доступ к связанным записям:
Cвязь «один-со-многими».
Из вторичной получить первичную.
Из вторичной модели можно получить связанную запись первичной модели посредством атрибута класса, представляющего поле внешнего ключа:
	>>> b.rubric.name
	'Недвижимость'
	>>> b.rubric.pk
	1 
Из первичной получить вторичную.
Атрибут первичной модели с именем вида <имя связанной вторичной модели>_set хранит диспетчер обратной связи, через него можно получить доступ ко всем записям вторичной модели связанными с этой записью первичной модели.( Также можно задать имя этого атрибута через параметр related_name.)
	>>> from bboard.models import Rubric
	>>> r = Rubric.objects.get(name='Heдвижимocть')
	>>> for bb in r.bb_set.all(): print(bb.title)
	Земельный участок
	Дом 
Посмотрим, есть ли там что-нибудь дешевле 10 ООО руб.:
	>>> for bb in r.bb_set.filter(price__lte=1OOOO): print(bb.title) 

Связь «один-с-одним».
Из вторичной получить первичную.
Из вторичной модели можно получить доступ к связанной записи первичной модели через атрибут класса, представляющий поле внешнего ключа:
	>>> from testapp.models import AdvUser
	>>> au = AdvUser.objects.first()
	>>> au.user
	<User: admin>
	>>> au.user.username
	'admin'

Из первичной получить вторичную.
Из первичной модели можно получить доступ к связанной записи вторичной модели через атрибут класса, чье имя совпадает с именем вторичной модели:
	>>> from django.contrib.auth import User
	>>> u = User.objects.first()
	>>> u.advuser
	<AdvUser: AdvUser object (1)> 
	
Связь "многие-со-многими"
Из вторичной получить первичную.
Через атрибут класса ведущей модели, представляющий поле внешнего ключа, доступен диспетчер обратной связи, представляющий набор связанных записей ведомой модели:
	>>> from testapp.models import Machine
	>>> m = Machine.objects.get(pk=1)
	>>> m.name
	'Самосвал'
	>>> for s in m.spares.all(): print(s.name)
	Гайка
	Винт 

Из первичной получить вторичную.
В ведомой модели будет присутствовать атрибут класса <имя связанной ведущей модели>_set. Его можно использовать для доступа к записям связанной ведущей модели. Пример:
	>>> from testapp.models import Spare
	>>> s = Spare.objects.get(name='Гaйкa')
	>>> for m in s.machine_set.all(): print(m.name)
	Самосвал 

- Извлечение одной записи
first() - возвращает первую запись набора или None, если набор пуст:
	>>> b = Bb.objects.first()
	>>> b.title
	'Стиральная машина' 
last() - возвращает последнюю запись набора или None, если набор пуст
earliest( [<имя поля 1>, <имя поля 2> . . . <имя поля п>]) - возвращает запись, у которой значение даты и времени, записанное в полях с указанными именами, является наиболее ранним. Если в модели указан параметр get_latest_by, задающий поля для просмотра метод можно вызвать без параметров. [-<имя поля 1>] - возвращает самое позднее.
	>>>b = Bb.objects.earliest('published')
	>>> b.title
	'Дача'
latest() - то же самое, что earliest(),но ищет запись с наиболее поздним значением даты и времени.

Все эти методы поддерживаются классами Manager, RelatedМanager и QuerySet. Следовательно, мы можем вызывать их также у набора связанных записей:
	>>> # Найдем самое раннее объявление о продаже транспорта
	>>> r = Rubric.objects.get(name='Tpaнcпopт')
	>>> Ь = r.bb_set.earliest('published')
	>» b.title
	'Мотоцикл'

- Получение количества записей в наборе
exists() - возвращает True, если в наборе есть запись, и False, если набор записей пуст.
	>>> # Проверяем, продают ли у нас сантехнику
	>>> r = Rubric.objects.get(name='Caнтexникa')
	>>> Bb.objects.filter(rubric=r).exists()
	False
count() - возвращает количество записей, имеющихся в наборе:
	>>>#А сколько у нас всего объявлений? ..
	>>> Bb.objects.count()
	12
Эти методы выполняются очень быстро, поэтому для проведения простых проверок рекомендуется применять именно их.  

- Поиск записи
get(<условия поиска>)  Если совпадающая с заданными условиями запись нашлась, она будет возвращена в качестве результата. Если ни одной подходящей записи не бьmо найдено, будет возбуждено исключение DoesNotExist, класс которого является вложенным в класс модели, чья запись не была найдена. Если же подходящих записей оказалось несколько, возбуждается исключение MultipleObjectsReturned из модуля django.core.exceptions. 

Если в методе get() указать сразу несколько условий поиска, они будут объединяться по правилам логического И:
	>>> r = Rubric.objects.get(pk=5, nаmе='Сантехника')

Если в модели есть хотя бы одно поле типа DateField или DateTimeField, модель получает поддержку методов:
get_next_by_<имя поля>()
get_previous_Ьу_<имя поля>() 
	>>> Ь = Bb.objects.get(pk=1)
	>>> b.title
	'дача'
	>>> Ь2 = b.get_next_by_published(price__lt=1OOO)
	>>> Ь2.title
	'Мотоцикл'

Если текущая модель является вторичной, и у нее было задано произвольное переупорядочивание записей, связанных с одной и той же записью первичной модели (т.е. был указан параметр order_with_respect_to), эта вторичная модель получает поддержку методов:
get_next_in_order()
get_previous_in_order()
	>>> r = Rubric.objects.get(name='Meбeль')
	>>> ЬЬ2 = r.bb_set.get(pk=34)
	>>> bb2.pk
	34
	>>> bb3 = bb2.get_previous_in_order()
	>>> bb3.рk
	37  


- Фильтрация записей 
Под фильтраций здесь понимается отбор только тех записей, которые удовлетворяют заданным критериям, причем, в отличие от поиска, таких записей может быть произвольное количество (в том числе и ноль, что не воспринимается фреймворком как нештатная ситуация и не приводит к возбуждению исключения). 

filter(<условия фильтрации>) - отбирает из текущего набора только те записи, которые удовлетворяют заданным условиям фильтрации. 
exclude(<условия фильтрации>) - то же самое, что filter(), но, наоборот, отбирает записи, не удовлетворяющие заданным условиям фильтрации.

Поскольку оба эти метода поддерживаются классом QuerySet, мы можем "сцепляты" их вызовы друг с другом.

	>>> r = Rubric.objects.get(name='Heдвижимocть')
	>>> for b in Bb.objects.filter(rubric=r).filter(price__lt=1OOOOOO):
	print(b.title, end=' ')
или
	>>> for b in Bb.objects.filter(rubric=r, price__lt=1OOOOOO):
	print(b.title, end=' ') 

Если нам нужно выполнить фильтрацию без учета регистра или отобрать записи, у которых значение поля больше или меньше заданной величины - необходимо использовать модификаторы. Такой модификатор добавляется к имени поля и отделяется от него двойным символом подчеркивания: <имя поля>__<модификатор>.

Модификаторы:
exact(iexact) - Точное совпадение, применяется в случаях, если имя какого-либо поля совпадает с ключевым словом Python.
contains(icontains) - Заданное значение должно присутствовать в значении, хранящемся в поле.
startswith(istartswith) Заданное значение должно присутствовать в начале значения,ся
endswith(iendswith) Заданное значение должно присутствовать в конце значения
i - Регистр символов не учитывается
----------- -----
lt/lte/gt/gte - сравнение со значением поля
----------- -----
range Диапазон значений задается в виде кортежа, первым элементом которого записывается начальное значение, вторым - конечное
----------- -----
date Значение, хранящееся в поле, рассматривается как дата. Пример:
published_date=datetime.date(2018, 6, 1)
year/month/day/week/week_day/quarter/hour/minute/second
published__year=2018
published__year__lte=2017
----------- -----
in - Значение, хранящееся в поле, должно присутствовать в указанном списке, кортеже или наборе записей QuerySet. Пример:pk__in=(l, 2, 3, 4) 
regex(iregex) - Значение, хранящееся в поле, должно совпадать с заданным регулярным выражением. Регистр символов учитывается. Пример:
content__regex='гaз|вoдa' 

- Фильтрация по значениям полей связанных записей.
Чтобы выполнить фильтрацию записей вторичной модели по значениям полей из первичной модели, мы запишем условие фильтрации в формате <имя поля внешнего ключа>__<имя поля первичной модели>. Для примера выберем все объявления о продаже транспорта:
	>>> for b in Bb.objects.filter(rubric_name='Tpaнcnopт'):
	print(b.title, end=' ')
	Велосиnед Мотоцикл 
Для выполнения фильтрации записей первичной модели по значениям из полей вторичной модели следует записать условие вида <имя вторичной модели>__<имя поля вторичной модели>. В качестве примера выберем все рубрики, в которых есть объявления о продаже с заявленной ценой более 10ООО руб.:
	>>> for r in Rubric.objects.filter(bb__price__gt=1OOOO):
	print (r.name, end=' ')
	Недвижимость Недвижимость Недвижимость Трансnорт
О способе выводить только уникальные записи позже.


- Сравнение со значениями других полей









	
	
	
	
	
	
	
	
	
	
	
	
	
	 



























